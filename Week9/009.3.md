# Validations on our Edit

Yesterday we looked at editing an existing contact, today we will add the ability to validate those changed before they are set on the model. To do this we are going to use Dockyard's companion addon to Ember Changeset: [Ember Changeset Validations](https://github.com/DockYard/ember-changeset-validations).

To get started let's go ahead and install the addon and a create a directory for our validations.

```sh
ember install ember-changeset-validations
mkdir app/validations
```

Next, we will create a file inside app/validations called contact.js. This is were we will setup our validation object. For ember-changeset-validations our validations object is just a plain JavaScript Object and setting up validations is super straight forward. We just import the validations that we want to use from the changeset validators library. Then we create keys for all the properties we want to validate. We will validate the presence of our firstName, lastName, email, and phone. To have multiple validations on a property, we just use an array to validate the length of firstName and phone.

`app/validations/contact.js`:

```JavaScript
import {
  validatePresence,
  validateLength
} from 'ember-changeset-validations/validators';
export default {
  firstName: [
    validatePresence(true),
    validateLength({ min: 4 })
  ],
  lastName: validatePresence(true),
  email: validatePresence(true),
  phone: [
    validatePresence(true),
    validateLength({ min: 10, max: 20 }),
  ]
};
```

It is worth noting that we can easily setup our own validations as well, but that is outside our present scope. After we have our validation object set up, we just import this validation object into the parent controller and add it to the controller object.

`app/controllers/contacts/contact/edit.js`:

```JavaScript
import Ember from 'ember';
import ContactValidations from '../../../validations/contact';

export default Ember.Controller.extend({
  ContactValidations,
  actions: {
    submit(changeset) {
     return changeset.save().then(()=>{
       this.transitionToRoute('contacts.contact.index');
     });
   },
   rollback(changeset) {
     return changeset.rollback();
   }
 }
});
 ```

We then pass in the validation object as the second parameter when creating the changeset: ContactValidations

`app/templates/contacts/contact/edit.hbs`:

```handlebars
{{edit-card model=model
            changeset=(changeset model ContactValidations)
            submit=(action "submit")
            rollback=(action "rollback")}}
```

Now, let's go back to our edit controller and use our new validations. On our changeset object we have access to some validation methods like `validate`  that checks our changeset against the validations that we set up. For our purposes, we can just check the changeset's `isValid` property. If the changeset is not valid we want to display something to our user, if it is valid, we want to go ahead and save the changeset.

The errors that are returned look like this:

```JSON
[
  {
    "key":"firstName",
    "value":"",
    "validation":[
      "First name can't be blank",
      "First name is too short (minimum is 2 characters)"
    ]
  }, {
    "key":"lastName",
    "value":"",
    "validation":[
      "Last name can't be blank"
    ]
  }
]
```

We really just want to get the validation message and print it out to the user. So, let's set up a function on the Edit controller that will get those validations and return them in a single array so that we can easily iterate over them in our template. We will just get the errors from the changeset, use map to get the validation array and use reduce and concat to flatten that array.

Back in `app/controllers/contacts/contact/edit.hbs`:

```JavaScript
getTheErrors(changeset){
  return changeset.get('errors').map(error => error.validation)
                                .reduce((topArr, nestedArr) => { return topArr.concat(nestedArr); }, []);
}
```

Now, let's set up our save action to use this method. Here we just want to check if our changeset is valid if it is, we save it and transition back to the index route the same as before, if it is not valid we we will set an `errorArray` property to our flattened error array. Also, when we submit without errors we want to set that `errorArray` property back to null as well.

`app/controllers/contacts/contact/edit.hbs`:

```JavaScript
actions: {
  submit(changeset) {
    if(Ember.get(changeset, 'isValid')){
      this.set('errorArray', null);
      return changeset.save().then(()=>{
        this.transitionToRoute('contacts.contact.index');
      });
    } else {
      this.set('errorArray', this.getTheErrors(changeset));
    }
  },
  ...
}
```

We then need to display our errors if we have any. There are several, perhaps better ways to do this, but let's be as explicit as possible. Just pass the errorArray from the edit controller to the edit-card component as a prop.

`app/templates/contacts/contact/edit.hbs`:

```handlebars
{{edit-card model=model
            errorArray=errorArray
            changeset=(changeset model ContactValidations)
            submit=(action "submit")
            rollback=(action "rollback")}}
```

Finally, display the errors in the `edit-card` component's template.

`app/templates/components/edit-card.hbs`:

```handlebars
{{#if errorArray}}
  <div class="alert alert-danger">
    <ul>
      {{#each errorArray as |error| }}
        <li>{{error}}</li>
      {{/each}}
    </ul>
  </div>
{{/if}}
```

That is it for today. Tomorrow we will look at deleting a record and creating a record. See you then.

## Links

[DockYard/ember-changeset-validations](https://github.com/DockYard/ember-changeset-validations)
[Dockyard's Example Ember Twiddle](https://ember-twiddle.com/e5eaa7bee6ed76257f5a62e618c315e8?fileTreeShown=false&openFiles=controllers.application.js%2C)
