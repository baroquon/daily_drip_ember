# Ember CLI Mirage

In the last episode we looked at acceptance testing our Ember application. But, our acceptance tests were weak and fragile. To truly test our apps well, we need good data. That is where (Ember CLI Mirage)[http://www.ember-cli-mirage.com/] can help us. With Mirage we can intercept our app's API requests and use (Pretender)[https://github.com/pretenderjs/pretender] to generate mocks.

Let's get started. We are going to continue working on the [events-app](https://github.com/baroquon/events-app/tree/003.3) from the last couple of episodes. We'll need to do a little setup to get our events-app ready for Mirage. First, we need to create an application adapter. The application adapter will apply to all Ember models that dop not have their own named adapter. For instance, an Event model will use the adapter at `app/adapters/application.js` unless we create an adapter at `app/adapters/event.js`. Let's create our application adapter. From the project root type:

```sh
$ ember g adapter application
```

In your new adapter add a namespace property with the value `api`:

```JavaScript
import JSONAPIAdapter from 'ember-data/adapters/json-api';

export default JSONAPIAdapter.extend({
  namespace: 'api'
});
```

Also, change the route to call out to Ember Data for its model. In `app/routes/events.js` uncomment the  `return` and delete all of the fixture data.

```JavaScript
import Ember from 'ember';

export default Ember.Route.extend({
  model(){
    return this.store.findAll('event');
  }
});
```

Now, we are ready to get started with Mirage. Installing Mirage is as easy as installing any Ember addon. In your project's root directory type:

```sh
$ ember install ember-cli-mirage
```

You can think of Mirage as a fake API server. Just as we would set up routes on our server to respond to Ember's requests, we will set up routes in Mirage. To get started we will create Mirage versions of our Ember models. In our case we have an `Address` model and an `Event` model.

```sh
$ ember g mirage-model event && ember g mirage-model address
```

In the mirage models is where we will need to set up the relationships. In `mirage/models/event.js`:

```JavaScript
import { Model, belongsTo } from 'ember-cli-mirage';

export default Model.extend({
  address: belongsTo()
});
```

And add the inverse in the `Address` model.

```JavaScript
import { Model, belongsTo } from 'ember-cli-mirage';

export default Model.extend({
  event: belongsTo()
});
```

Now, let's create the routes to respond with these newly generated models. Right now, we'll just respond to find all and find record for addresses and events. In `mirage/config.js` add:

```JavaScript
  this.get('/events', (schema, request) => {
    return schema.events.all();
  });
  this.get('/events/:id', (schema, request) => {
    return schema.events.find(request.params.id);
  });

  this.get('/addresses', (schema, request) => {
    return schema.addresses.all();
  });
  this.get('/addresses/:id', (schema, request) => {
    return schema.addresses.find(request.params.id);
  });
```

Now, we need to add our factories.

```sh
$ ember g mirage-factory event && ember g mirage-factory address
```

Now we need to populate our factories.
