# Solution and Prep

This week we are going to put some of our new found knowledge about Routes and Components into use by continuing to iterate on the simple contacts application that we started in (Week 1)[https://github.com/baroquon/daily_drip_ember/blob/master/Week1/001.4.md].

## Solution

In the last exercise you were tasked with creating an app that has a component which displays an attribute that you can modify and whose changes will be persisted when you navigate away from the component. This was a pretty open ended task and there are many ways to solve the issue. Let's look at one possible solution.

First, we'll need an Ember app.

```sh
ember new exercise-002-5
cd exercise-002-5
```

Generate a couple of routes and a component:

```sh
ember g route index && ember g route about
ember g component example-component
```

Add our component and a header to the index template (`app/templates/index.hbs`):

```hbs
<h1>Index Route</h1>
{{example-component}}
```

Add a header to our about template (`app/templates/about.hbs`):
```hbs
<h1>About Route</h1>
```

Add a few link-to helpers in the application template (`app/templates/application.hbs`):

```hbs
{{link-to 'Index' 'index'}}
<br>
{{link-to 'About' 'about'}}
<br>
{{outlet}}
```

Now, let's go ahead and display an attribute in the component's template and bind the value of that attribute to an input helper. In (`app/templates/components/example-component.hbs`):

```hbs

{{input value=someAttr}}
<br>
<br>
<strong>someAttr:</strong> {{someAttr}}
```

At this point if we enter a value in out input in the index page, and navigate to the about page and pack to the index page, our value would be reset. So, how to we persist it? We could just pass in the attribute from the controller by calling the component like this:

```hbs
{{example-component someAttr=someControllerProp}}
```

This binds the value in our component to a value in the controller. Since the controller is a singleton and the value from the controller is passed into the component, the value lives on after the component has gone away. But, this isn't really a great way to operate. Also, in future versions of Ember (maybe who knows?), when/if glimmer components land, two-way data binding will no longer be the default behavior. We can avoid binding the attribute by using the unbound helper:

```hbs
{{example-component someAttr=(unbound someControllerProp)}}
```

Let's try setting up an action in our willDestroyElement hook on our Component that will send the attribute to be stored on the controller.

```js
willDestroyElement(){
  let attr = this.get('someAttr');
  this.get('setPropOnController')(attr);
}
```

Then we will pass an action from the controller to the component:

```hbs
{{example-component someAttr=(unbound someControllerProp) setPropOnController=(action 'persistComponentAttr')}}
```

Finally, let's create that controller action that we are passing into the component.

```sh
ember g controller index
```

In `app/controllers/index.js`:

```JavaScript
import Ember from 'ember';

export default Ember.Controller.extend({
  actions: {
    persistComponentAttr(prop){
      this.set('someControllerProp', prop);
    }
  }
});
```

That about does it. So, this isn't really the way I would build this in a production app, but it should show just what is available and how we can solve some basic problems with Ember components. Spoilers: I would use a service for persisting any component properties rather than a controller. But since we haven't really talked about services yet, controllers will do for now. See you tomorrow.

## Resources:

* [The Ember Component Docs](http://emberjs.com/api/classes/Ember.Component.html)
* You can review the [Ember Component Lifecycle hooks](https://guides.emberjs.com/v2.6.0/components/the-component-lifecycle/)
* To understand a bit about the wider world of components it would be useful to look over the [W3C Custom Elements Spec](http://w3c.github.io/webcomponents/spec/custom/)
