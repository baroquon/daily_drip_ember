# Unit and Integration Tests

Today we are going to look at testing our Ember application. Ember uses QUnit as its built in testing framework. You can choose a different framework like mocha if you prefer. For our purposes, we will first create a component then we will write a basic integration test followed by a simple unit test. Finally, we will write a basic acceptance test.

# Getting Started

We will start by creating a basic application.

```sh
$ ember new testable-app
$ cd testable-app
```

Once inside our new app's directory we will generate a component.

```sh
$ ember g component testable-widget
```
Now you can run your tests by typing `ember test`. You will notice that on running your test, you will have several jshint tests that should all pass, and you will have one integration test. When we generated our component Ember also created for us a shell of an integration test. If we open up that test and take a look we'll be able to see what is going on. Open `tests/integration/components/testable-widget-test.js`

```js
import { moduleForComponent, test } from 'ember-qunit';
import hbs from 'htmlbars-inline-precompile';

moduleForComponent('testable-widget', 'Integration | Component | testable widget', {
  integration: true
});

test('it renders', function(assert) {
  // Set any properties with this.set('myProperty', 'value');
  // Handle any actions with this.on('myAction', function(val) { ... });

  this.render(hbs`{{testable-widget}}`);

  assert.equal(this.$().text().trim(), '');

  // Template block usage:
  this.render(hbs`
    {{#testable-widget}}
      template block text
    {{/testable-widget}}
  `);

  assert.equal(this.$().text().trim(), 'template block text');
});
```

Let's walk through this. This test section contains two assertions and for these two assertions we are rendering our component twice, once inline and once as a block. The first assertion `assert.equal...` is testing the inline render and the second is testing the block. We'll make our component render both inline and block, so we'll leave them both. The selector `this.$()` gives us access to the rendered component. I'm going to start by changing the tests so that both will fail.

```js
this.render(hbs`{{testable-widget title="Widget Header" content="Some content"}}`);

assert.equal(this.$('h2').text().trim(), 'Widget Header');
assert.equal(this.$('.content-container').text().trim(), 'Some content');

// Template block usage:
this.render(hbs`
  {{#testable-widget title='Widget Block Title'}}
    The block text.
  {{/testable-widget}}
`);

assert.equal(this.$('h2').text().trim(), 'Widget Block Title');
assert.equal(this.$('.content-container').text().trim(), 'The block text.');
```

Now, if we run our tests, they will fail. Let's open our component and make these tests pass. In `app/templates/components/testable-widget.hbs`:

```hbs
<h2>{{title}}</h2>
<div class='content-container'>
  {{#if hasBlock}}
    {{yield}}
  {{else}}
    {{content}}
  {{/if}}
</div>
```

Here, we'll create a header with our passed in title. Then, we'll create a div with the `content-container` class. Finally, we'll add an handlebars `if` helper with the component's built in `hasBlock` property. If the component is rendered as a block we yield the content in the component block. If we have an inline component we will render the value that we passed in as the `content`. Now, our tests will pass. Let's add one more integration test before moving on to a unit test.
